<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>Beigesoft™ Accounting. Export/import data to/from CSV file.</title>
  </properties>

  <body>

    <!-- The body of the document contains a number of sections -->
    <section name="Beigesoft™ Accounting. Export/import data to/from CSV file.">

      <h4>CSV format</h4>
      <p>
        Data separators:
        <ul>
          <li>comma</li>
          <li>semicolon</li>
          <li>etc</li>
        </ul>
        line ending:
        <ul>
          <li>CR/LF - Windows</li>
          <li>LF - Linux</li>
          <li>CR - Mac</li>
        </ul>
        Date formats:
        <ul>
          <li>MM/dd/yyyy - USA</li>
          <li>dd/MM/yyyy - others</li>
          <li>etc</li>
        </ul>
        Text encoding:
        <ul>
          <li>UTF-8</li>
          <li>US-ASCII</li>
          <li>ISO-8859-1</li>
          <li>etc</li>
        </ul>
        Columns names may be present or not.
      </p>
      
      <h4>Common CSV data models and services</h4>
      <p> Model org.beigesoft.model.ECsvColumnType:
        <ul>
          <li>STRING</li>
          <li>BOOLEAN</li>
          <li>INTEGER</li>
          <li>NUMERIC</li>
          <li>DATE</li>
        </ul>
      </p>
      <p>
        Persistable model org.beigesoft.persistable.CsvMethod
        <ul>
          <li>AHasIdLongNameVersion fields</li>
          <li>charsetName, String, not null, Charset encoding name, "UTF-8" default.</li>
          <li>columnSep, String[5], not null, Column separator, comma default.</li>
          <li>hasHeader, Boolean, not null, if the first row contains of columns names, false default.</li>
          <li>columns - List(CsvColumn), Csv Columns all or useful to read</li>
        </ul>
      </p>
      <p>
        Persistable model org.beigesoft.persistable.CsvColumn
        <ul>
          <li>AHasIdLongNameVersion fields</li>
          <li>itsOwner - CsvMethod</li>
          <li>itsType, ECsvColumnType, not null</li>
          <li>itsIndex, Integer, not null, start from 1 index.</li>
          <li>sourceIndex, Integer, not null, start from 1 index in source file cause some columns might be omitted.</li>
          <li>textDelimiter - String, null default, Column's text braced with delimiters, null default,
            e.g. quoted - "taxes, penalty and other fees are included"</li>
          <li>dataFormat - String, null default, Column's data format, null default, e.g. "dd/MM/yyyy" for Date,
            "space,comma" for number "123 31,78EUR", "true,false" for Boolean</li>
          <li><b>rules to write:</b></li>
          <li>constValue - String, null default, constant for default value for all rows, e.g. "1" for column "isTaxIncludedInPrice"</li>
          <li>dataIndex - Integer, if used, index of data column, starts from 1.</li>
          <li>fieldPath - String, if used, comma separated full class name plus fields names trough destination field, e.g.
            "org.beigesoft.accounting.persistable.InvItem,itsCategory,itsId" to retrieve product.getItsCategory().getItsId() from column with given dataIndex.</li>
          <li>matchForeign - MatchForeign method, if used.</li>
        </ul>
      </p>
      <p>Basic reading service that reads next line from CSV file ICsvReader, methods:
        <ul>
          <li>readNextRow(Map&lt;String, Object&gt; pReqVars, pReader Reader, CsvMethod pCsvMethod) - returns List&lt;String&gt; list of String values of all columns from next row, null if no more rows left. May throws an Exception</li>
        </ul>
        This is performance, memory and algorithmically friendly service.
      </p>

      <h4>Universal CSV writer</h4>
      <p>Abstraction of retrieving data is table of objects. In simple cases it's list, i.e. row contains only column.
        For example list of products List&lt;InvItem&gt;, in case of exporting to the same software result file example:
<pre style="white-space: pre-wrap;">
defUnitOfMeasure,itsCategory,itsId,itsName,itsType,knownCost,taxCategory
1,1,1,Chocolate A,1,2.33,1
1,1,2,Chocolate B,1,,1
1,2,3,Chocolate C,1,,1
</pre>
here is no need to create CsvMethod with CsvColumn list, universal service (writer/reader) do it itself, field list ordered by name, owned entities passed as ID, enums as value index.
      </p>
      <p>In case of exporting into another software, other data might be required. Some of these data can be constant, empty (optional).
      For example "tax is included in price" for price list is usually same for all products, recipient software accept 1 as "included" and 0 as "NOT", so just set property constValue in CsvColumn to used value.</p>
      <p>So, in case of customized data exporting we have:
        <li>List&lt;List&lt;Object&gt;&gt; - data table, where Object can be any business data model, e.g. InvItem, DebtorCreditor, BigDecimal, Boolean, String, etc.</li>
        <li>CsvMethod with CsvColumn list that also handle data that is not present in data table.</li>
      </p>
      <p>Example of exporting price list. Required file example:
<pre style="white-space: pre-wrap;">
Product,ProductCode,Cost,Markup,Price,TaxPercent,IsTaxIncudedInPrice,Discount,Supplier,Place,Quantity,Category
Chocolate A,1,1.00,20.00,1.20,3.4,0,0.00,,room1,12,food
Chocolate B,2,1.00,25.00,1.25,3.4,0,0.00,,room1,11,food
Beverage A,3,2.00,25.00,2.50,3.4,0,0.00,,room1,11,beverage
</pre>
      Retrieved data table columns:
        <ul>
          <li>InvItem - product</li>
          <li>BigDecimal - price</li>
          <li>BigDecimal - aggregate or only tax rate</li>
        </ul>
        We do not want to pass data: cost, markup, supplier, quantity.
        So, markup is constant 0%, cost is price, supplier is empty, place constant "room a", quantity is constant 777777,
        IsTaxIncudedInPrice is constant 0, discount is constant 0. Cost is volatile thing and depends of used method (FIFO,etc).
        Sometimes, price can be less than cost.
      </p>
      <p>There are three methods to make other columns:
        <ul>
          <li>reveal value from data table by given class and fields names, e.g. Product = InvItem.get("itsName") and ProductCode = InvItem.get("itsId")</li>
          <li>matching foreign value to value of retrieving field value of given class, e.g. ProductCategoryId = InvItem.get("itsCategory").get("itsId") -> findIn[{1,"food"},{2,"drink"}]</li>
          <li>reveal value by equation and using data table, e.g. cost=round(price/1.2, 2)</li>
        </ul>
      </p>
      <p>Implementation of "reveal value from data table by given class and fields names" method.
        CsvColumn has fields "dataIndex" - index of data column, "fieldPath" - comma separated full class name plus fields
        names trough destination field, e.g.
        "org.beigesoft.accounting.persistable.InvItem,itsCategory,itsId"
        to retrieve product.getItsCategory().getItsId() then farther matching to foreign value.
        Java reflects API do this according given data.
        JSP view should implements interactively pickup data class and destination field, to make this string automatically.
      </p>
      <p>Implementation of "reveal value by equation and using data table" method.
        This method not yet implemented cause it's useless yet.</p>
      <p>Implementation of "matching foreign value" method. In simple cases string like "1,food,2,drink" is enough.
        In case when number of values is huge, e.g. product codes is different in source and destination software, then
        persistable model MatchForeign is used:
        <ul>
          <li>AHasIdLongNameVersion fields</li>
          <li>className - String, not null, full class name of the entity, e.g. org.beigesoft.accounting.persistable.InvItemCategory</li>
          <li>fieldName - String, not null, field name to match, e.g. itsId</li>
          <li>itsLines - List&lt;MatchForeignLine&gt;</li>
        </ul>
        persistable model MatchForeignLine:
        <ul>
          <li>AHasIdLongVersion fields</li>
          <li>nativeVal - String, not null, native value</li>
          <li>foreignVal - String, not null, foreign value</li>
          <li>nativeValLong - Long, optional, only for ID value in current database to make SQL queries, hidden field</li>
        </ul>
        Because of easy "persistable models implementation" by BeigeORM and BeigeWEBCRUD, only it is used. So, CsvColumn has optional field matchForeign. If it's not empty, then this method will be applies.
        Fields className and fieldName is used to interactively pickup native value. In additional, using nativeValLong to match entities with Long ID allows make SQL queries and retrieve foreign value in data table,
        so no need additional matching.
      </p>
      <p>
        Universal service that writes CSV file according given data table and CSV method ICsvWriter:
        <ul>
          <li>write(Map&lt;String, Object&gt; pReqVars, List&lt;List&lt;?&gt;&gt; pData, CsvMethod csvMethod, String pFilePath)</li>
        </ul>
      </p>

      <h4>Import bank statement. Semi-automatically bank reconciliation.</h4>
      <p>
        When CSV file contains of entry like:
<pre style="white-space: pre-wrap;">
  01/01/2018,check#123 wrong signature,VOIDED,123.45
</pre>
then it means that check#123 for 123.45 was canceled, so application should try to find payment or prepayment with matching amount and date and suggest to reverse that document. 
      </p>
      <p>Business logic "completing bank statement line":
      <ul>
        <li>when field "resultAction" is empty, then field is not yet completed</li>
        <li>where is two complete actions - "adding new record" and "report already matching record"</li>
        <li><b>when "finding canceled mode" is set to on and line marked as "canceled"</b> - matching non-reversed and reversed accounting prepayments/payments/accounting entries will be listed - action "reverse" will be appeared for non-reversed records and action "report matching" will be appeared for already reversed records.</li>
        <li>when line has status "ACCEPTED", then matching non-reversed prepayments/payments/accounting entries will be listed to report "matching", actions "new payment/prepayment/accounting entry" will be appeared in any case</li>
      </ul>
      </p>
      <p>
        After user made any suggesting action, result should be listed for the line where action was made, e.g. "created reversing payment#67 for 12.34USD".
      </p>
      <p>Persistable model BankCsvMethod:
        <ul>
          <li>AHasIdLongNameVersion fields</li>
          <li>csvMethod, CsvMethod, not null</li>
          <li>dateCol - CsvColumn, not null, date</li>
          <li>amountCol - CsvColumn, not null, amount, Standard value is dot separated
            number without group separators e.g. "11245.23", otherwise accepted
            formats: "COMMA,SPACE" European standard - "11 245,45",
            but in that case column value must be braced with text delimiter,
            e.g. quotes; "COMMA,NONE" - "11245,45". All other separators should be
            original, i.e. dot is ".", e.g. ".,NONE" is default format</li>
          <li>descriptionCol - CsvColumn, if used, description</li>
          <li>statusCol - CsvColumn, if used, column that contains of CANCELED or NOT information</li>
          <li>acceptedWords - String, if used, comma separated words that mean that entry was ACCEPTED, e.g. "OK,ACCEPTED" or single value "true"</li>
          <li>voidedWords - String, if used, comma separated words that mean that entry was CANCELED, e.g. "VOIDED,CANCELED" or single value "false"</li>
        </ul>
        "finding canceled mode" is set to on when statusCol and voidedWords are filled.
      </p>
      <p>Persistable model BankStatement:
        <ul>
          <li>APersistableBaseVersion fields, version changed time</li>
          <li>bankAccount, BankAccount, not null</li>
          <li>itsDate - Date, not null</li>
          <li>sourceName - String, CSV file name + BankCsvMethod name</li>
          <li>itsLines - List&lt;BankStatementLine&gt;</li>
          <li>description - String, description created by user, e.g. "line #45 made mistake, see adjusting entry #123"</li>
        </ul>
      </p>
      <p>Persistable model BankStatementLine, constTypeCode() = 1010:
        <ul>
          <li>APersistableBaseVersion fields, implements IHasTypeCode, version changed time</li>
          <li>itsOwner, BankStatement, not null, read only field</li>
          <li>itsDate - Date, not null, from CSV, read only field</li>
          <li>itsAmount - BigDecimal, not null, negative or positive - from CSV, read only field</li>
          <li>descriptionStatus - String, from CSV if present, read only field, if statusCol presents, then string value will be present here.</li>
          <li>itsStatus - EBankEntryStatus.ACCEPTED/VOIDED, ACCEPTED default or from CSV according settings, read only field</li>
          <li>resultAction - EBankEntryAction.CREATE/MATCH, null default, read only, create record or found matching record</li>
          <li>resultDescription, String, if line completed, read only field, e.g. "created PaymentTo#12665" or "found PaymentTo#12665"</li>
          <li>resultRecordId, Long, if new record made, read only field</li>
          <li>resultRecordType, EBankEntryResultType.ACC_ENTRY/PAYMENTFROM/PREPAYMENTFROM/PAYMENTTO/PREPAYMENTTO, if new record made, read only field</li>
        </ul>
        Only action per line is allowed. If user made mistake, then it should fix it "by hand", i.e. add adjusting accounting entry, etc.
      </p>

      <h4>Export goods/services list to POS</h4>
      <p>In theory, CSV price list should contains:
        <ul>
          <li><b>required data:</b></li>
          <li>goods/service name</li>
          <li>goods/service ID (code)</li>
          <li>price (of course)</li>
          <li>tax method - describes which taxes applies and how, is it included into price</li>
          <li><b>optional data:</b></li>
          <li>is it service</li>
          <li>unit of measure</li>
          <li>its category name and ID, e.g. "chocolate bars"/201</li>
          <li>price method - describes discount, etc. e.g. 15% off at the mornings...</li>
          <li>barcode</li>
          <li>picture file name</li>
          <li>available quantity - to prevent selling more than given number, it may be 0 to stop selling this goods.</li>
        </ul>
      </p>
      <p>In real life POS wants other data, but most of them are usually optional:
        <ul>
          <li>is available</li>
          <li>cost</li>
          <li>supplier</li>
          <li>location</li>
          <li>etc</li>
        </ul>
      </p>
      <p>
        There are also numerous means to pass tax and price methods:
        <li>
          <li>several fields - tax rate, is included in price, etc</li>
          <li>several fields - tax name, tax rate</li>
          <li>several fields - tax name1, tax rate1, tax name2, tax rate2, etc</li>
          <li>only field - aggregate tax rate</li>
          <li>several fields - etc</li>
          <li>only field - discount</li>
          <li>only field - ID of tax method</li>
          <li>only field - ID of price method</li>
        </li>
      </p>
      <p>Tax method - on item or on invoice basis is settled in POS for all goods, it's also applies for tax is included in price. If POS demand these data, then add these as constants.</p>
      <p>Shop in downtown use different prices than shop in suburb. In other hand online and retail prices usually different.
        Beigesoft Webstore (it's actually trading system) has persistable models:
        <ul>
          <li>PriceCategoryOfItems - name (e.g. retail shop#1), description</li>
          <li>PriceCategoryOfBuyers - name, description</li>
          <li>PriceCategory - name (e.g. retail shop#1), item price category (required), buyer price category (optional), is retail only (to prevent use it in online WEB-Store)</li>
          <li>PriceGoods - goods, price category (e.g. retail shop#1), price</li>
        </ul>
      </p>

    </section>

  </body>

</document>
